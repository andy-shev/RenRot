#!/usr/local/bin/perl -w

#
# $Id$
#

use strict;
require 5.006;
use Time::localtime;
use Time::Local;
use Image::ExifTool;
use Getopt::Long;

our $VERSION = "0.20rc2";	# the version of this script
my $maxVerbosity = 4;		# our max verbosity level (internal)

########################################################################################
#
# Parsed configuration file in hash
#
my %configOptions = (
			'aggregation delta' => 900,
			'aggregation directory' => 'DIR',
			'aggregation mode' => 'none',
			'aggregation template' => '%Y%m%d',
			'comment file' => undef,
			'mtime' => 1,
			'name template' => '%Y%m%d%H%M%S',
			'tag ciadrcity'  => undef,
			'tag ciadrctry' => undef,
			'tag ciadrextadr' => undef,
			'tag ciadrpcode' => undef,
			'tag ciadrregion' => undef,
			'tag ciemailwork' => undef,
			'tag citelwork' => undef,
			'tag ciurlwork' => undef,
			'tag usercomment' => undef,
		    );

########################################################################################
#
# Command line options
#
my $aggrDelta;		# aggregation time delta in seconds (file with delta > $aggrDelta is placed in new DIR)
my $aggrDir;		# counterless directory name for "delta" type aggregation
my $aggrMode;		# define aggregation mode, possible values are: none, delta or template
my $aggrTemplate;	# template for the files aggregation taken from CLI
my $comfile;		# file with commentary
my $configFile;		# config file
my $countFF = 1;	# use fixed field for counter
my $countStart = 1;	# Start value for counter
my $countStep = 1;	# Step for counter
my $dryRun;		# show what would have been happened
my @excludeList;	# files that will be excluded from list
my $extToProcess = '';	# the extension of files to work with
my @files;		# array of the sorted filenames to process
my $mtime;		# mtime taken from CLI
my $nameTemplate;	# template for the filename taken from CLI
my $noRename;		# no rename needed, default is to rename to the YYYYmmddHHMMSS.ext
my $noRotation;		# no rotation needed, default is to rotate
my $orientTag = 0;	# rotate by changing Orientation tag (no real rotation)
my $oldCfg = 0;		# use old style of configuration file
my $quiet = 0;		# suppressing messages
my $rotateAngle;	# define the angle to rotate on 90, 180 or 270
my $rotateThumbnail; 	# define the angle to rotate on 90, 180 or 270
my %tags;		# define tags for filling
my $userComment;	# text to put into UserComment tag
my $verbose = 0;	# verbosity of output
my $workDir = './';	# we'll work ONLY in current directory

########################################################################################
#
# Global variables (internal)
#
my %rotangles = (
			'90' => '-rotate 90',
			'180' => '-rotate 180',
			'270' => '-rotate 270'
		);	# array of options to rotate file "by hands"

# processing message ( ? necessary to consult man GetOptions sub { $verbose = 0 } )
sub procmsg {
	print @_ if ($quiet == 0);
}

# information message
sub infomsg {
	print STDERR @_;
}

# warning message
sub warnmsg {
	print STDERR "Warning: ", @_;
}

# error message
sub errmsg {
	print STDERR "ERROR: ", @_;
}

# fatal message
sub fatalmsg {
	print STDERR "FATAL: ", @_;
}

# debug message
sub dbgmsg {
	my $level = shift;
	if ($verbose >= $level) {
		print STDERR "DEBUG[$level]: ", @_;
	}
}

########################################################################################
#
# boolConv() converts boolean value to human readable string
#
sub boolConv {
	my $var = shift;
	if ($var == 0) {
		return "No";
	} else {
		return "Yes";
	}
}

########################################################################################
#
# boolConverter() converts given string to a boolean value
#
sub boolConverter {
	my $value = shift;
	if ($value =~ m/^(0|No|False|Off)$/i) {
		return 0;
	} elsif ($value =~ m/^(1|Yes|True|On)$/i) {
		return 1;
	}
	return $value;
}

########################################################################################
#
# getOptions() parses command line arguments
#
sub getOptions {
	my $showVersion = 0;	# need version
	my $showHelp = 0;	# need help
	my @tmpTags;
	my $aggr = 0;		# execute aggregation after main process
	my $aggrDumb;		# no real moving to catalogues done, only to sho how it'll be without this flag
	my $getOptions = GetOptions (
					"aggr!" => \$aggr,
					"aggr-delta=i" => \$aggrDelta,
					"aggr-directory=s" => \$aggrDir,
					"aggr-dumb!" => \$aggrDumb,
					"aggr-mode=s" => \$aggrMode,
					"aggr-template=s" => \$aggrTemplate,
					"comment-file=s" => \$comfile,
					"config-file|c=s" => \$configFile,
					"counter-fixed-field!" => \$countFF,
					"counter-start=i" => \$countStart,
					"counter-step=i" => \$countStep,
					"dry-run" => \$dryRun,
					"exclude=s" => \@excludeList,
					"extension|e=s" => \$extToProcess,
					"help|?"   => \$showHelp,
					"mtime!" => \$mtime,
					"name-template=s" => \$nameTemplate,
					"no-rename" => \$noRename,
					"no-rotate" => \$noRotation,
					"old-config!" => \$oldCfg,
					"only-orientation" => \$orientTag,
					"quiet|q" => \$quiet,
					"rotate-angle|r=i" => \$rotateAngle,
					"rotate-thumb=i" => \$rotateThumbnail,
					"tag=s" => \@tmpTags,
					"user-comment=s" => \$userComment,
					"v+" => \$verbose,
					"version" => \$showVersion,
					"work-directory|d=s" => \$workDir,
				    );

	my $fileCount = scalar(@ARGV);

	dbgmsg (3, "   --aggr-delta: $aggrDelta\n") if (defined $aggrDelta);
	dbgmsg (3, "   --aggr-directory: $aggrDir\n") if (defined $aggrDir);
	dbgmsg (3, "   --aggr-mode: $aggrMode",
		   "   --aggr: ", boolConv($aggr),
		   "   --aggr-dumb: ", defined $aggrDumb ? boolConv($aggrDumb) : "undef",
		   "\n") if (defined $aggrMode);
	dbgmsg (3, "   --aggr-template: $aggrTemplate\n") if (defined $aggrTemplate);
	dbgmsg (3, "   --comment-file: $comfile\n") if (defined $comfile);
	dbgmsg (3, "   --config-file: $configFile\n") if (defined $configFile);
	dbgmsg (3, "   --counter-start: $countStart",
		   "   --counter-step: $countStep",
		   "   --counter-fixed-field: ", boolConv($countFF), "\n");
	dbgmsg (3, "   --dry-run: ", boolConv($dryRun), "\n") if (defined $dryRun);
	dbgmsg (3, "   --exclude:\n", join("\n", @excludeList), "\n") if (scalar(@excludeList) > 0);
	dbgmsg (3, "   --extension: $extToProcess\n");
	dbgmsg (3, "   --mtime: ", boolConv($mtime), "\n") if (defined $mtime);
	dbgmsg (3, "   --name-template: $nameTemplate\n") if (defined $nameTemplate);
	dbgmsg (3, "   --no-rename: ", boolConv($noRename), "\n") if (defined $noRename);
	dbgmsg (3, "   --no-rotate: ", boolConv($noRotation), "\n") if (defined $noRotation);
	dbgmsg (3, "   --old-config: ", boolConv($oldCfg), "\n");
	dbgmsg (3, "   --only-orientation: ", boolConv($orientTag), "\n");
	dbgmsg (3, "   --rotate-angle: $rotateAngle\n") if (defined $rotateAngle);
	dbgmsg (3, "   --rotate-thumb: $rotateThumbnail\n") if (defined $rotateThumbnail);
	dbgmsg (3, "   --tag:\n", join("\n", @tmpTags), "\n") if (scalar(@tmpTags) > 0);
	dbgmsg (3, "   --work-directory: $workDir\n");
	dbgmsg (3, "   ARGV:\n", join("\n", @ARGV), "\n") if ($fileCount > 0);

	if ($showHelp != 0) {
		usage();
		exit 0;
	}

	if ($showVersion != 0) {
		infomsg ("RenRot version $VERSION\n");
		exit 0;
	}

	if ($extToProcess eq "" and ($fileCount == 0)) {
		fatalmsg ("Extension of files is required!\n");
		exit 1;
	}

	if ($getOptions == 0) {
		usage();
		exit 1;
	}

	# Validate angle value
	if ((defined $rotateAngle and not grep(/^$rotateAngle$/, keys %rotangles)) or
	    (defined $rotateThumbnail and not grep(/^$rotateThumbnail$/, keys %rotangles))) {
		fatalmsg ("Angle should be 90, 180 or 270!\n");
		exit 1;
	}

	# Convert:
	#   --no-aggr => --aggr-mode='none'
	#   --aggr and --aggr-template='delta' => --aggr-mode='delta'
	#   --aggr and --aggr-template='%Y%m%d' => --aggr-mode='template'
	if (not defined $aggrMode) {
		if ($aggr == 0) {
			$aggrMode = 'none';
		} else {
			if ($aggrTemplate eq "delta") {
				$aggrMode = 'delta';
			} else {
				$aggrMode = 'template';
			}
		}
	}

	# Convert --aggr-dumb to --dry-run
	$dryRun = $aggrDumb if (not defined $dryRun and defined $aggrDumb);

	# Change user's parameter '*.ext' or 'ext' to '.ext'
	$extToProcess =~ s/^\*?\.?/\./ if ($fileCount == 0);
	dbgmsg (1, "getOptions(): Process with '$extToProcess' extension.\n");

	# Convert multiple tag parameters to tags hash
	foreach my $tag (@tmpTags) {
		my ($key, $value) = parsePair($tag);
		if (defined $key) {
			$value = "" if (not defined $value);
			$tags{$key} = $value;
		} else {
			warnmsg ("Invalid tag format: $tag\n");
		}
	}
}

########################################################################################
#
# trimValue() removes heading and trailing spaces
#
sub trimValue {
	my $value = shift;
	$value =~ s/\s*([^\s]+.*[^\s]+)\s*/$1/;
	return $value;
}

########################################################################################
#
# parsePair() gets (key, value) pair from the string like [multiword] key = "value"
#
sub parsePair {
	my $value = shift;
	my ($key, $val) = (undef, undef);
	if ($value =~ m/^([^=]+)=(.+)/) {
		($key, $val) = (trimValue($1), trimValue($2));
		$val =~ s/^[\'\"](.+)[\'\"]/$1/;	# trim quotes
		dbgmsg (4, "parsePair(): Parsed: '$key' <- '$val'\n");
	} elsif ($value =~ m/^([^=]+)=$/) {
		$key = trimValue($1);
		dbgmsg (4, "parsePair(): Parsed empty '$key'\n");
	}
	return ($key, $val);
}

########################################################################################
#
# getConfig() parses configuration file
#
sub getConfig {
	my $file = shift;

	my %hConfig;

	if (open (CFGFILE, "<$file")) {
		my @cfgfile = <CFGFILE>;
		unless (close (CFGFILE)) { errmsg ("$file wasn't closed!\n"); }
		my $i = 0;
		while ($i < scalar(@cfgfile)) {
			my $line = $cfgfile[$i++];

			# skip empty and comment lines
			next if (($line =~ m/^\s*$/) or ($line =~ m/^\s*#/));

			$line =~ s/#(.*)$//;				# remove trailing comments

			my ($key, $value) = parsePair($line);
			if (defined $value) {
				$key = lc($key);
				$hConfig{$key} = boolConverter($value);
				dbgmsg (3, "getConfig(): Parsed line($i): '$key' <- '$hConfig{$key}'\n");
			} else {
				warnmsg ("Unparsed line $i in configuration file.\n");
			}
		}
	} else {
		errmsg ("Can't open configuration file: $file\n");
	}

	return %hConfig;
}

########################################################################################
#
# parseConfig() parses user's or standart configuration files to hash
#
sub parseConfig {
	my $file = shift;
	my @rcFiles = (
			"/etc/renrot.rc",
			"/usr/local/etc/renrot.rc",
			$ENV{"HOME"} . "/" . ".renrotrc",
		      );

	@rcFiles = ($file) if (defined $file);
	my $rcfile;
	if ($oldCfg == 0) {
		foreach $rcfile (@rcFiles) {
			if (-f $rcfile) {
				my %tmpConfig = getConfig($rcfile);
				foreach my $key (keys %tmpConfig) {
					$configOptions{$key} = $tmpConfig{$key};
				}
			}
		}
		return;
	}

	our $COMMENTARY;
	our $CiAdrCity;
	our $CiAdrCtry;
	our $CiAdrExtadr;
	our $CiAdrPcode;
	our $CiAdrRegion;
	our $CiEmailWork;
	our $CiTelWork;
	our $CiUrlWork;
	our $Mtime = 1;
	our $NameTemplate = '%Y%m%d%H%M%S';
	our $AggrTemplate = '%Y%m%d';
	our $AggrDelta = 900;
	our $AggrDir = 'DIR';
	our $AggrDumb = 1;

	foreach $rcfile (@rcFiles) {
		do $rcfile if (-f $rcfile);
	}

	%configOptions = (
				'aggregation delta' => $AggrDelta,
				'aggregation directory' => $AggrDir,
				'aggregation dumb' => $AggrDumb,
				'aggregation template' => $AggrTemplate,
				'mtime' => $Mtime,
				'name template' => $NameTemplate,
				'tag ciadrcity' => $CiAdrCity,
				'tag ciadrctry' => $CiAdrCtry,
				'tag ciadrextadr' => $CiAdrExtadr,
				'tag ciadrpcode' => $CiAdrPcode,
				'tag ciadrregion' => $CiAdrRegion,
				'tag ciemailwork' => $CiEmailWork,
				'tag citelwork' => $CiTelWork,
				'tag ciurlwork' => $CiUrlWork,
				'tag usercomment' => $COMMENTARY,
			 );
}

########################################################################################
#
# MAIN() renames and rotates given files
#

# parse command line options
getOptions();

my $lce = lc($extToProcess);		# low cased extension
my $etpLen = length($extToProcess);	# length of given extension
@files = @ARGV;				# all things in ARGV will be treated as file names to process

my $exiftoolVerbose = ($verbose > $maxVerbosity) ? ($verbose - $maxVerbosity) : 0;

parseConfig($configFile);

# redefining options set in config with set via CLI ones
$configOptions{'aggregation delta'}	= $aggrDelta if (defined $aggrDelta);
$configOptions{'aggregation directory'}	= $aggrDir if (defined $aggrDir);
$configOptions{'aggregation mode'}	= $aggrMode if (defined $aggrMode);
$configOptions{'aggregation template'}	= $aggrTemplate if (defined $aggrTemplate);
$configOptions{'comment file'}		= $comfile if (defined $comfile);
$configOptions{'mtime'}			= $mtime if (defined $mtime);
$configOptions{'name template'}		= $nameTemplate if (defined $nameTemplate);
$configOptions{'tag usercomment'}	= $userComment if (defined $userComment);

# converting aggregation dumb value to --dry-run option
if (not defined $dryRun) {
	if (defined $configOptions{'aggregation dumb'}) {
		$dryRun = $configOptions{'aggregation dumb'};
	} else {
		$dryRun = 0;		# make actions by default
	}
}
dbgmsg (1, "Show what would have been happened (no real actions).\n") if ($dryRun != 0);

# Validate aggregation mode possible values
if (not grep (/^$configOptions{'aggregation mode'}$/, ('none', 'delta', 'template'))) {
	warnmsg ("Aggregation mode isn't correct! Resetting to 'none'.\n");
	$configOptions{'aggregation mode'} = 'none';
}

# ExifTool object configuration
our $exifTool = new Image::ExifTool;
$exifTool->Options(Binary => 1, Unknown => 1, DateFormat => '%Y%m%d%H%M%S', Verbose => $exiftoolVerbose);

our $counterprefixsize;	# number of digits in $counterprefix
my $file;		# file in the directory
my @filenames;		# array of the filenames to process
my $newfilename;	# the name file to be renamed to
my %filenameshash;	# hash for old file names
my $filenameshashkey;	# keys %filenameshash
my $comment;		# where to put the commentary to write
my $counterprefix;	# file number counter

my @rotparms = (''
	, '-flip horizontal'
        , '-rotate 180'
        , '-flip vertical'
        , '-transpose'
        , '-rotate 90'
        , '-transverse'
        , '-rotate 270');	# array of options to jpegtran to rotate the file

my @angles = ( ''
	, 'fh'
	, '180cw'
	, 'fv'
	, 'tp'
	, '90cw'
	, 'tv'
	, '270cw' );	# the array of suffixes to add to the newfilename after rotating

my %rotorient = (
	1 => 0,
	6 => 90,
	3 => 180,
	8 => 270
);

my %rotorientrev = reverse %rotorient;

chdir ($workDir) || ( fatalmsg ("Can't enter to $workDir!\n"), die );

# if no file is given
if (scalar(@files) == 0) {
	opendir(DIR, "./") || ( fatalmsg ("Can't open $workDir!\n"), die );
	while ( defined ( $file = readdir DIR )) {
		next if (! -f $file);			# skip absent file or not a file
		push @files, $file;
	}
	closedir(DIR);
}

# independently of @files initialization doing this
foreach $file ( @files ) {
	next if (! -f $file);				# skip absent file or not a file
	next if (grep {/^$file$/} @excludeList);	# skip excluded file
	if (substr($file, length($file) - $etpLen) eq $extToProcess) {
		push @filenames, $file;
	}
}

# No file to process?
if (scalar(@filenames) == 0) {
	fatalmsg ("No files to process!\n");
	exit 1;
}

# Prepare software string for EXIF injection
my $softwareString = sprintf("ExifTool v%s, RenRot v%s", $Image::ExifTool::VERSION, $VERSION);
dbgmsg (1, "main(): Software: $softwareString\n");

# Preparing the variable, which contains the format of the counter output
if ($countFF != 0) {
	my $size = length((scalar(@filenames) - 1) * $countStep + $countStart);
	$counterprefixsize = "%." . $size . "d";
	dbgmsg (1, "main(): Counter size: $size (amount files in cache: ", scalar(@filenames), ")\n");
} else {
	$counterprefixsize = "%d";
}

@files = sort @filenames;
dbgmsg (4, "main(): Pushed files(", scalar(@files), "):\n", join("\n", @files), "\n");

our $anglesuffix;	# the suffix to add to the end of the rotated files 90cw, 180cw or 270cw
my $orientation;	# Orientation tag value
my $info;		# ImageInfo object
my $fileCounter = $countStart;

procmsg ("RENAMING / ROTATING\n===================\n");

foreach $file ( @files ) {
	procmsg ("Processing file: $file ...\n");

	# Setup defaults
	$info = $exifTool->ImageInfo($file);
	$newfilename = "";
	$anglesuffix = "0cw";

	################################################################################################
	#
	## analyzing whether to rotate
	#

	$orientation = $exifTool->GetValue("Orientation", 'ValueConv');

	if ( defined $noRotation ) { dbgmsg (2, "main(): No rotation asked, file orientation is left untouched.\n"); }
	elsif ( defined $rotateAngle ) {
		dbgmsg (2, "main(): We'll deal with: $file and $rotangles{$rotateAngle}.\n");
		if ($orientTag != 0) {
			rotateOrient($file, $orientation);
		} else {
			rotateFile($file, $rotangles{$rotateAngle});
			rotateThumbnail($file, $rotangles{$rotateAngle});
		}
		$anglesuffix = $rotateAngle . "cw";
	}
	elsif ( defined $rotateThumbnail ) {
		rotateThumbnail($file, $rotangles{$rotateThumbnail});
	}
	else {
		if (defined $orientation) {
			if ( $orientation > 1 ) {
				rotateFile($file, $rotparms[$orientation - 1]);
				rotateThumbnail($file, $rotparms[$orientation - 1]);
				$anglesuffix = $angles[$orientation - 1];
			}
			elsif ( $orientation == 1 ) {
				dbgmsg (2, "main(): No need to rotate, orientation is: Horizontal (normal).\n");
			}
			else {
				errmsg ("Something wrong, orientation low than 1: $orientation.\n");
			}
		}
		else {
			warnmsg ("Orientation tag is absent!\n");
		}
	}

	#################################################################################
	#
	## analyzing whether and how to rename file
	#
	if ( defined $noRename ) {
		dbgmsg (2, "main(): No renaming asked, filename is left untouched.\n");
		my $fweLen = length($file) - $etpLen;		# length of filename w/o extension
		if ((substr($file, $fweLen) eq $lce) and
		    ($newfilename = substr($file, 0, $fweLen)) ne "") {
			$filenameshash{$newfilename} = getUnixTime(getTimestamp($exifTool, $info));
		}
	}
	else {
		$newfilename = template2name($exifTool,
					     $info,
					     $configOptions{'name template'},
					     $fileCounter);
		if ( $filenameshash{$newfilename} ) {
			$newfilename .= "." . sprintf($counterprefixsize, $fileCounter);
		}
		$filenameshash{$newfilename} = getUnixTime(getTimestamp($exifTool, $info));

		$newfilename .= $lce;

		if ( $file ne $newfilename ) {
			if ( -f $newfilename ) {
				fatalmsg ("File $newfilename already exists!\n"), die;
			}
			rename ( $file, $newfilename )
				|| ( fatalmsg ("Unable to rename $file -> $newfilename.\n"), die );
			procmsg ("Renamed: $file -> $newfilename\n");
		}
		else { warnmsg ("No renaming needed for $newfilename, it looks as needed!\n"); }
	}

	###############################
	#
	## analyzing whether to comment
	#
	if ($configOptions{'comment file'}) {
		if (open(COMMENT, "<$configOptions{'comment file'}")) {
			my @commentar = <COMMENT>;
			unless (close(COMMENT)) { errmsg ("$configOptions{'comment file'} wasn't closed!\n"); }
			$comment = join ( '', @commentar );
			# preparing to write the commentary
			$exifTool->SetNewValue(Comment => $comment);
		}
	}
	else { dbgmsg (2, "main(): No commenting, file commentary is left untouched.\n"); }

	# Writting tags.
	tagWriter($exifTool, $newfilename) if (not defined $noRename);

	# seting mtime for the file if been asked for
	mtimeSet($exifTool, $info, $newfilename);

	procmsg ("\n");
	$fileCounter += $countStep;
}

aggregationProcess();

exit 0;

########################################################################################
#
# mtimeSet() sets mtime for the given file
#
sub mtimeSet {
	my $exifToolObj = shift;
	my $infoObj = shift;
	my $file = shift;
	if ($configOptions{'mtime'} != 0) {
		my $mTime = getUnixTime(getTimestamp($exifToolObj, $infoObj));
		utime $mTime, $mTime, $file;
		dbgmsg (2, "mtimeSet(): Changing mtime for $file OK.\n");
	}
}

########################################################################################
#
# tagWriter() writes couple of tags defined via configuration file and command line
#
sub tagWriter {
	my $exifToolObj = shift;
	my $file = shift;

	if (defined $configOptions{'tag usercomment'}) {
		$exifToolObj->SetNewValue(UserComment => $configOptions{'tag usercomment'});
	}

	if (defined $configOptions{'tag ciadrcity'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiAdrCity', $configOptions{'tag ciadrcity'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag ciadrctry'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiAdrCtry', $configOptions{'tag ciadrctry'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag ciadrextadr'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiAdrExtadr', $configOptions{'tag ciadrextadr'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag ciadrpcode'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiAdrPcode', $configOptions{'tag ciadrpcode'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag ciadrregion'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiAdrRegion', $configOptions{'tag ciadrregion'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag ciemailwork'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiEmailWork', $configOptions{'tag ciemailwork'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag citelwork'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiTelWork', $configOptions{'tag citelwork'}, Group => 'XMP');
	}
	if (defined $configOptions{'tag ciurlwork'}) {
		$exifToolObj->SetNewValue('CreatorContactInfoCiUrlWork', $configOptions{'tag ciurlwork'}, Group => 'XMP');
	}

	$exifToolObj->SetNewValue('Software', $softwareString, Group => 'EXIF');

	# writing the changes to the EXIFs
	exifWritting($exifToolObj, $file, $file . "_comment");
}

########################################################################################
#
# exifWritting() applies EXIF info
#
sub exifWritting {
	my $exifToolObject = shift;
	my $fileSrc = shift;
	my $fileDst = shift;

	my $result = $exifToolObject->WriteInfo($fileSrc, $fileDst);
	if ($result == 1) {
		dbgmsg (2, "exifWritting(): Writing to $fileDst seems to be OK.\n");
		rename ($fileDst, $fileSrc)
			|| ( fatalmsg ("$fileDst -> $fileSrc\n"), die );
	} elsif ($result == 2) {
		warnmsg ("No changes between $fileSrc and $fileDst. No EXIF was written.\n");
		unlink $fileDst;
	} else {
		my $errorMessage   = $exifToolObject->GetValue('Error');
		my $warningMessage = $exifToolObject->GetValue('Warning');
		if ( defined $errorMessage ) { errmsg ("ExifTool: $errorMessage\n"); }
		if ( defined $warningMessage ) { warnmsg ("ExifTool: $warningMessage\n"); }
	}
	return $result;
}

########################################################################################
#
# aggregationProcess() aggregates files to separate directories by request
#
sub aggregationProcess {
	return if ($configOptions{'aggregation mode'} eq "none");

	my $file;
	my $info;
	my $NewDir;

	procmsg ("AGGREGATION\n===========\n");

	if ($configOptions{'aggregation mode'} eq "template") {
		dbgmsg (1, "aggregationProcess(): Template: $configOptions{'aggregation template'}\n");
		my $fileCounter = $countStart;

		foreach $file (sort (keys %filenameshash)) {
			$file .= $lce;
			dbgmsg (4, "aggregationProcess(): Processing file: $file\n");
			$info = $exifTool->ImageInfo($file);
			$NewDir = template2name($exifTool,
						$info,
						$configOptions{'aggregation template'},
						$fileCounter);
			aggregateFile($file, $NewDir) if ($dryRun == 0);
			procmsg ("Aggregate: $file -> $NewDir\n", "\n");
			$fileCounter += $countStep;
		}
	} elsif ($configOptions{'aggregation template'} eq "delta") {
		my $DirCounter = 1;
		my $timestampPrev;
		my $filePrev;
		my $filetmp;

		foreach $file (sort (keys %filenameshash)) {
			$filetmp = $file;
			$file .= $lce;
			dbgmsg (4, "aggregationProcess(): Processing file: $file\n");
			$info = $exifTool->ImageInfo($file);

			if ($DirCounter == 1) {
				$timestampPrev = $filenameshash{$filetmp};
				$filePrev = $filetmp;
				$NewDir = $configOptions{'aggregation directory'} . sprintf($counterprefixsize, $DirCounter);
				$DirCounter++;
				aggregateFile($file, $NewDir) if ($dryRun == 0);
			} else {
				# Check for new direcroty creation
				if (($filenameshash{$filetmp} - $timestampPrev) > $configOptions{'aggregation delta'}) {
					$NewDir = $configOptions{'aggregation directory'} . sprintf($counterprefixsize, $DirCounter);
					$DirCounter++;
				}
				aggregateFile($file, $NewDir) if ($dryRun == 0);
				$timestampPrev = $filenameshash{$filetmp};
			}
			procmsg ("Aggregate: $file -> $NewDir\n", "\n");
		}
	} else {
		errmsg ("Aggregation mode $configOptions{'aggregation mode'} isn't implemented!");
	}
}

########################################################################################
#
# aggregateFile() moves file to new directory
#
sub aggregateFile {
	my $file = shift;
	my $NewDir = shift;

	if (not -d $NewDir) {
		unless (mkdir $NewDir) { errmsg ("$NewDir wasn't created!\n"); }
	}
	my $newfilename = $NewDir . "/" . $file;
	rename ($file, $newfilename) || ( fatalmsg ("$file -> $newfilename\n"), die );
}

########################################################################################
#
# timeNow() returns timestamp in form YYYYmmddHHMMSS
#
sub timeNow {
	my $date = localtime();
	my $timeNow = sprintf("%.4d%.2d%.2d%.2d%.2d%.2d",
		$$date[5] + 1900, $$date[4] + 1, $$date[3],
		$$date[2], $$date[1], $$date[0]);
	return $timeNow;
}

########################################################################################
#
# timeValidator() returns correctness of timestamp in form YYYYmmddHHMMSS
#
sub timeValidator {
	my $timestamp = shift;

	# check length (14)
	return 1 if (length($timestamp) != 14);

	my @tm = ($timestamp =~ m/(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/);
	return 1 unless @tm == 6;
	dbgmsg (4, "timeValidator(): @tm\n");

	if (
		# check year
		($tm[0] < 1900) or
		# check month
		(($tm[1] > 12) or ($tm[1] < 1)) or
		# check day
		(($tm[2] > 31) or ($tm[2] < 1)) or
		# check hour, minute, second
		($tm[3] > 23) or ($tm[4] > 59) or ($tm[5] > 59)
	   ) {
		return 1;
	}

	return 0;
}

########################################################################################
#
# getTimestamp() returns EXIF timestamp in form YYYYmmddHHMMSS if exists, otherwise
# it returns timeNow()
#
sub getTimestamp {
	my $exifToolObj = shift;
	my $infoObj = shift;

	my $timestamp;

	if (defined $infoObj->{"DateTimeOriginal"} and not timeValidator($infoObj->{"DateTimeOriginal"})) {
		$timestamp = $infoObj->{"DateTimeOriginal"};
	}
	elsif (defined $infoObj->{"FileModifyDate"} and not timeValidator($infoObj->{"FileModifyDate"})) {
		$timestamp = $infoObj->{"FileModifyDate"};
	}
	else {
		$timestamp = timeNow();
		$exifToolObj->SetNewValue('FileModifyDate', $timestamp, Group => 'File');
		warnmsg ("EXIF timestamp isn't correct, using timeNow()!\n");
	}

	return $timestamp;
}

########################################################################################
#
# getUnixTime() converts timestamp to unix time form
#
sub getUnixTime {
	my $timestamp = shift;
	my @tm = ($timestamp =~ m/(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/);
	$tm[0] -= 1900;     # convert year
	$tm[1] -= 1;        # convert month
	@tm = reverse @tm;  # change to order required by timelocal()
	return Time::Local::timelocal(@tm);
}

########################################################################################
#
# rotateOrient() rotates image by changing Orientation tag. No real rotation
# will be made.
#
sub rotateOrient {
	my $fileOrient = shift;
	my $orientation = shift;

	dbgmsg (4, "rotateOrient(): Original Orientation: $orientation\n");
	my $angleTmp = $rotorient{$orientation};
	if (not defined $angleTmp) {
		errmsg ("Operation not permited for mirror orientation\n");
		return;
	}

	$angleTmp += $rotateAngle;
	$angleTmp -= 360 if ($angleTmp >= 360);

	$orientation = $rotorientrev{$angleTmp};
	dbgmsg (4, "rotateOrient(): New Orientation: $orientation\n");

	$exifTool->SetNewValue("Orientation", $orientation, Type => 'ValueConv');
	exifWritting($exifTool, $fileOrient, $fileOrient . "_orient");
}

########################################################################################
#
# rotating the image and it's thumbnail, rewriting Orientation tag and the commentary
# to the result file
#
sub rotateFile {
	# $_[0] - file name to transform with jpegtran
	# $_[1] - the switches for jpegtran to transform the image

	my $oldfile =  $_[0];			# original name
	my $origfile = $_[0] . "_orig";	# backup original name
	my $newfile =  $_[0] . "_rotated";	# temporay name to store rotated file
	my $addon =    $_[1];

	# jpegtran the image
	my $cmd = "jpegtran -copy all $addon -outfile \"$newfile\" \"$oldfile\"";
	dbgmsg (3, "rotateFile(): $cmd\n");
	system $cmd || ( fatalmsg ("System $cmd failed: $?\n"), die );

	rename ( $oldfile, $origfile ) || ( fatalmsg ("$oldfile -> $origfile\n"), die );
	rename ( $newfile, $oldfile )  || ( fatalmsg ("$newfile -> $oldfile\n"), die );

	# preparing to write Orientation tag to the just rotated file
	my $exifAfterRot = new Image::ExifTool;
	$exifAfterRot->Options(Binary => 1);

	$exifAfterRot->SetNewValue("Orientation", 1, Type => 'ValueConv');

	# writing the changes to the EXIFs
	exifWritting($exifAfterRot, $oldfile, $oldfile . "_exifed");
}

########################################################################################
#
# rotate thubnail only, where the file was rotated but thumbnail was left untouched
#
sub rotateThumbnail {
	# $_[0] - file, which thumbnale to transform with jpegtran
	# $_[1] - the switch for jpegtran to rotate the thumbnail

	if ( defined ${$$info{ThumbnailImage}} ) {
		my $fileToThumbnail =  $_[0];			# original name
		my $addon =            $_[1];

		# extracting the thumbnail image
		my $ThumbnailOriginal = $fileToThumbnail . "_thumborig";
		unless ( open ( OLDTHUMBNAIL, ">$ThumbnailOriginal" ) ) {
			errmsg ("$ThumbnailOriginal wasn't opened!\n");
		}
		binmode OLDTHUMBNAIL;
		print OLDTHUMBNAIL ${$$info{ThumbnailImage}};
		unless ( close ( OLDTHUMBNAIL ) ) { warnmsg ("$ThumbnailOriginal wasn't closed!\n"); }

		# rotating the thumbnail
		my $ThumbnailOriginalRotated = $ThumbnailOriginal . "_rotated";
		my $cmd = "jpegtran -copy all $addon -outfile \"$ThumbnailOriginalRotated\" \"$ThumbnailOriginal\"";
		dbgmsg (3, "rotateThumbnail(): $cmd\n");
		system $cmd || ( fatalmsg ("System $cmd failed: $?\n"), die );

		# preparing to write the just rotated thumbnail, back to the file
		unless ( open ( THUMBNAILROTATED, "<$ThumbnailOriginalRotated" ) ) {
			errmsg ("$ThumbnailOriginalRotated wasn't opened!\n");
		}
		binmode THUMBNAILROTATED;
		my ( @rthumb ) = <THUMBNAILROTATED>;
		my $thethumb = join ('',@rthumb);
		unless ( close ( THUMBNAILROTATED ) ) { errmsg ("$ThumbnailOriginalRotated wasn't closed!\n"); }

 	 	# preparing to write thumbnale to the just rotated file
		my $exifThumbnailed = new Image::ExifTool;
		$exifThumbnailed->Options(Binary => 1);

		$exifThumbnailed->SetNewValue("ThumbnailImage", $thethumb, Type => 'ValueConv');

		# writing the changes to the EXIFs
		exifWritting($exifThumbnailed, $fileToThumbnail, $fileToThumbnail . "_thumb");

		unlink ($ThumbnailOriginalRotated) || ( fatalmsg ("While killing $ThumbnailOriginalRotated.\n"), die );
		unlink ($ThumbnailOriginal) || ( fatalmsg ("While killing $ThumbnailOriginal.\n"), die );
	}
	else {
		warnmsg ("No thumbnail found.\n");
	}
}

########################################################################################
#
# usage() - the instruction how to use the script
#
sub usage {
infomsg (
"Usage:	renrot 	<--extension EXTENSION> [--quiet] [--no-rotate] [--no-rename] [--name-template TPL] [--comment-file FILE] [--work-directory DIR] [[--] FILE1 FILE2 ...]

Options:
  -c, --config-file <FILE>	use this configuration file
  -d, --work-directory <DIR>	specify working directory
  --exclude <FILE> ...		define excluding files from process. No wildcards.
  -e, --extension <EXTENSION>	extension of files to be processed: JPG, jpg, JPEG e.t.c.
  --name-template <TPL>		filename template (see manual for details)
  --no-rename			no rename needed, default is to rename to the YYYYmmddHHMMSS.ext
  -r, --rotate-angle <ANGLE>	define the angle to rotate file and the thumbnail on 90, 180 or 270 (it's for the files where no Orientation tag is present and set right way)
  --rotate-thumb <ANGLE>	rotate only thumbnail by 90, 180 or 270 degree (it's for the files which were rotated, but thumbnail wasn't)
  --only-orientation		rotate by changing Orientation tag (no real rotation)
  --no-rotate			no rotation needed, default is to rotate
  --mtime (*)			to set file mtime according DateTimeOriginal tag value
  --aggr-mode <MODE>		run aggregation in MODE (possible values are: none, delta or template)
  --aggr-delta <INTERVAL>	aggregation time delta (file with delta great than INTERVAL is placed to the --aggr-directory followed by directory name counter starting from 1)
  --aggr-directory <DIR>	counterless aggregation directory name
  --aggr-template <TPL>		aggregation template (see manual for details)
  --comment-file <FILE>		file with commentary
  --user-comment <COMMENTARY>	text to put into UserComment tag
  --dry-run			show what would have been happened
  -v [-v -v ...]		amount of these options defines debug level
  -?, --help			display this help and exit
  --version			output version information and exit

(*) The option does not take an argument and may be negated, i.e. prefixed by 'no'. E.g. 'mtime' will allow '--mtime' (positive value will be assigned) and '--nomtime' and '--no-mtime' (negative value will be assigned).
");
}

########################################################################################
#
# template2name() - file name builder, according the template
#
sub template2name {
	my $exifToolObj = shift;
	my $infoObj = shift;
	my $template = shift;	# the template to be used
	my $fileNo = shift;	# counter for %c

	if (not defined $template) {
		fatalmsg ("Template isn't given!\n"), die;
	}

	my $timestamp = getTimestamp($exifToolObj, $infoObj);
	my @tm = ($timestamp =~ m/(\d\d(\d\d))(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/);
	dbgmsg (4, "template2name(): tm: @tm\n");

	my $ExposureTime = "";
	my $FileNumber = 'NA';
	my $FNumber = "";
	my $ISO = "";
	my $WhiteBalance = "";

	if (defined $infoObj->{"FileNumber"}) {
		$FileNumber = $infoObj->{"FileNumber"};
	}

	if (defined $infoObj->{"ExposureTime"}) {
		$ExposureTime = "E" . $infoObj->{"ExposureTime"};
		$ExposureTime =~ s/\//by/g;
	}

	if (defined $infoObj->{"FNumber"}) {
		$FNumber = "F" . $infoObj->{"FNumber"};
	}

	if (defined $infoObj->{"ISO"}) {
		$ISO = "I" . $infoObj->{"ISO"};
	}

	if (defined $infoObj->{"WhiteBalance"}) {
		$WhiteBalance = "W" . $infoObj->{"WhiteBalance"};
		$WhiteBalance =~ s/[\s()]//g;
	}

	my @templatearea = split (//, $template);
	my %templatehash = (
				'%' => "%",
				'a' => $anglesuffix,
				'c' => sprintf($counterprefixsize, $fileNo),
				'd' => $tm[3],
				'E' => $ExposureTime,
				'F' => $FNumber,
				'H' => $tm[4],
				'I' => $ISO,
				'i' => $FileNumber,
				'M' => $tm[5],
				'm' => $tm[2],
				'S' => $tm[6],
				'W' => $WhiteBalance,
				'Y' => $tm[0],
				'y' => $tm[1],
			   );
	my $thename = "";

	my $substroffset = 0;
	my $substrchar;

	dbgmsg (4, "template2name(): '$template' (length: " . scalar(@templatearea) .")\n");
	while ($substroffset < scalar(@templatearea)) {
		$substrchar = $templatearea[$substroffset++];
		if ($substrchar eq "%" and $substroffset < scalar(@templatearea)) {
			$substrchar = $templatearea[$substroffset++];
			if ( defined $templatehash{$substrchar} ) {
				$thename .= $templatehash{$substrchar};
			}
		}
		else { $thename .= $substrchar; }
	}

	return $thename;
}

__END__

=head1 NAME

renrot - rename and rotate images according EXIF data

=head1 SYNOPSIS

renrot [OPTIONS] [[B<-->] FILE1 FILE2 ...]

=head1 DESCRIPTION

B<RenRot> is intended to work with files of B<--extension> extension,
containing EXIF date and can do two things with them - rename and rotate. It
runs in batch mode in current or set with B<--work-directory> directory, as
well as selective mode for separate files given as arguments in command line.

RenRot renames files according the DateTimeOriginal and FileModifyDate EXIF
tags, if they exist. Otherwise, the name will be set according to the current
time stamp and will look as YYYYmmddHHMMSS.XXXX.ext, where XXXX is whether
file ID, if exists in EXIF (as for Canon) or incremental suffix to the name
YYYYmmddHHMMSS.

Additionally, it rotates files and their thumbnails, accordingly Orientation
EXIF tag. When the tag is absent or miss set, the program allows to rotate the
file as well as it's thumbnail via B<--rotate-angle> and B<--rotate-thumb>
options.

The script, also, is placing commentary into:

=over

- Commentary tag from file (see B<--comment-file> option)

- UserComment tag from configuration variable (see L<CONFIG> section)

=back

Personal details can be specified via XMP tags defined in a configuration
file, look L<CONFIG> section.

In addition, RenRot can aggregate all files in directories according the given
date/time pattern template, set with B<--aggr-template>.

=head1 OPTIONS

=over

=item B<-c> or B<--config-file> I<Configuration FILE>

location of the configuration file

=item B<-d> or B<--work-directory> I<DIR>

define the working directory

=item B<--exclude> I<FILE>

specify files to exclude. No wildcards are available. For set of files option
must be occured same times as files given.

=item B<-e> or B<--extension> I<EXTENSION>

extension of files to be processed, JPG, jpg, JPEG, CRW, crw e.t.c.

=item B<--name-template> I<Name TEMPLATE>

template, which is used for file name building while renaming. It could be
defined in configuration file (the variable Name Template). The default is
I<%Y%m%d%H%M%S>. For practical results look L<EXAMPLES> section.

Interpreted sequences are:

=over

B<%%>	a literal %

B<%c>	file order number in the processed file set

B<%d>	day of the month (01-31)

B<%E>	ExposureTime tag value if defined

B<%F>	FNumber tag value if defined

B<%H>	hour (00-23)

B<%I>	ISO tag value if defined

B<%i>	FileNumber tag if exists (otherwise, it'll be replaced by string
C<NA>)

B<%M>	minute (00-59)

B<%m>	month (01-12)

B<%S>	second (00-59)

B<%W>	WhiteBalance tag value if defined

B<%Y>	year (1900, 1901, and so on)

B<%y>	last two digits of year (00..99)

=back

=item B<--no-rename>

no rename needed, default is to rename to the YYYYmmddHHMMSS.ext

=item B<--rotate-angle> I<ANGLE>

define the angle to rotate file and the thumbnail on 90, 180 or 270. It's for
the files where no Orientation tag is set right way.

=item B<--rotate-thumb> I<ANGLE>

rotate only thumbnail by 90, 180 or 270 degree. It's for the files which were
rotated, but thumbnail wasn't.

=item B<--only-orientation>

rotate by changing Orientation tag, no real rotation will be made. The
sequence of values when rotating image from normal (0 degrees) by 90cw is: 0
-> 90 -> 180 -> 270 -> 0. It means set Orientation tag to 90cw after first
usage of rotation by 90cw and so on. For 270cw rotation algorithm uses
reversed sequence. Rotation by 180cw triggers values in two pairs: 0 <-> 180
and 90 <-> 270. This option can't be applied to mirror values of Orientation
tag.

=item B<--no-rotate>

no rotation needed, default is to rotate according EXIF data

=item B<--mtime>

defines, whether to set mtime of the file, using DateTimeOriginal tag value

=item B<--no-mtime>

opposite to B<--mtime>. mtime of the file will be the one after processing

=item B<--aggr-mode> I<MODE>

run aggregation process in given I<MODE>. Possible values are: none, delta or
template.

=item B<--aggr-delta> I<Time INTERVAL>

the type of aggregation "delta". Really it is aggregation time delta in
seconds (file with DateTimeOriginal and the one of the previous file delta,
greater than B<--aggr-delta> is placed to the B<--aggr-directory> followed by
directory name counter).

=item B<--aggr-directory> I<DIR>

counterless aggregation directory name

=item B<--aggr-template> I<Aggregation TEMPLATE>

template, which is used for file aggregation. Aggregation fulfils according
date/time patterns. You may use combination of B<%d>, B<%H>, B<%M>, B<%m>,
B<%S>, B<%Y>, and/or B<%y> keys. It could be defined in configuration file
(the variable Aggregation Template). The default is I<%Y%m%d>. For detailed
description, please, turn to B<--name-template> option. For practical results
look L<EXAMPLES> section.

=item B<--comment-file> I<Comment FILE>

file with commentary

=item B<--user-comment> I<User's COMMENTARY>

text to put into UserComment tag

=item B<--dry-run>

show what would have been happened (no real actions)

=item B<-v>

one or more I<-v> sets debug level. From 1 to 4 - internal levels, 5 till 9 -
equal to 1-5 levels for ExifTool plus maximum verbosity for renrot.

=item B<-?> or B<--help>

display quick help and exit

=item B<--version>

output version information and exit

=head1 B<EXAMPLES>

The name template C<01.%c.%Y%m%d%H%M%S.%i.%E%F%W%I> may produces following
names:

=over

01.0021.20030414103656.NA.E1by40F2.8WAutoI160.jpg

01.0024.20040131230857.100-0078.E1by320F2.8WAutoI50.jpg

01.0022.20000820222108.NA.jpg

=back

where I<F> stays for FNumber, I<E> for ExposureTime, I<I> for ISO and
I<W> for WhiteBalance.

The aggregation template C<%Y%m%d> produces following aggregation:

=over

this couple of files

=over

01.11.20030414103656.NA.jpg

01.12.20030414103813.NA.jpg

01.13.20030414103959.NA.jpg

=back

will be put to the directory I<20030414> and

=over

01.14.20040131130857.100-0078.jpg

01.15.20040131131857.100-0079.jpg

01.16.20040131133019.100-0080.jpg

01.17.20040131135857.100-0083.jpg

=back

will be put to the directory I<20040131>.

=back

=head1 CONFIG

Config file could be used to set some variables. Config file is just set of
case-insensivity keys and its values separated by equal sign. Boolean
variables can be defined via following keywords: 0, No, False, Off for false,
and 1, Yes, True, On for true. B<RenRot> looks for B<--config-file> option
firstly, than it looks for file named renrot.rc in system directories such as
/etc and /usr/local/etc. And finally it looks for file named .renrotrc in home
directory of the user. User defined configuration file can be given via
B<--config-file> option.

These variables could be set via configuration file:

=over

=item B<mtime>

set to Yes for synchronize mtime with tags, otherwise set it to No

=item B<name template>

name template, which defines the file name look (see B<--name-template>)

=item B<aggregation template>

aggregation template, which defines the file aggregation (see
B<--aggr-template>)

=item B<Tag UserComment>

anything you'd wanna put as commentary

=item B<Tag CiAdrCity>

city tag

=item B<Tag CiAdrCtry>

country tag

=item B<Tag CiAdrExtadr>

extended address (usually street and apartments)

=item B<Tag CiAdrPcode>

zip code

=item B<Tag CiAdrRegion>

region

=item B<Tag CiEmailWork>

email

=item B<Tag CiTelWork>

phone

=item B<Tag CiUrlWork>

URL

=back

=head1 FILES

Configuration file placement (with high priority first):

=over

=item B<~/.renrotrc>

=item B</usr/local/etc/renrot.rc>

=item B</etc/renrot.rc>

=back

=head1 AUTHORS

Copyright 2005-2006, Zeus Panchenko, Andy Shevchenko.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Image::ExifTool(3pm)|Image::ExifTool>,L<exiftool(1)>,L<jpegtran(1)>

=cut
